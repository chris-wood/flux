{"name":"flux","tagline":"","body":"# flux\r\n\r\n## Overview\r\n\r\nFlux is an imperative programing language that compiles to *executable \r\npacket flows.* The intent is to allow the network behavior of an application\r\nto be programmatically encoded without dealing with the application-layer \r\ndetails. The ultimate goal is to enable better experimentation of CCN-based\r\napplications, forwarders, and (forwarding, caching, etc.) strategies. \r\n\r\n## Workflow\r\n\r\nFlux compiles to instrumented ccnx-pktpusher files -- what are called programmable\r\npackets. The details of these instrumented files can be found in the ccnx-pktpusher\r\nproject. \r\n\r\n## Language Sketches\r\n\r\n### (1) flux DSL to specify flows\r\n\r\n- specify constants for keys, certificates, etc. (key chains, names of keys, etc.)\r\n- command to send interest (and specify return content size)\r\n- general control flow commands (loops, conditions)\r\n\r\n\r\nkey k1 = RSA(\"root\", 1024, nil)\r\nkey k2 = RSA(\"child\", 1024, k1)\r\n\r\n// TODO\r\n\r\nflow flowOneName(link l) {\r\n    while true {\r\n        // send and receive explicit\r\n        receive(l, \"/name/of/interest\", nil)\r\n        asyncSend(l, \"/name/of/interest\", nil)\r\n\r\n        // block send\r\n        send(l, \"/name/of/interest\", nil)\r\n        \r\n        // delays\r\n        uniformWait(0.05)\r\n        expWait(0.05)\r\n    }\r\n}\r\n\r\nlink l1 = Link(/prefix/) \r\nflowOneName(l1)\r\n\r\ndelay = exp(100) // uniform(100) (other distributions here)\r\nscheduleWithRepeat(flowOneName, l1, delay)\r\nschedule(flowOneName, l1, delay)\r\n\r\n## Language Grammar \r\n\r\na  ::= x | n | - a | a opa a\r\nb  ::= true | false | not b | b opb b | a opr a\r\nopa ::= + | - | * | /\r\nopb ::= and | or\r\nopr ::= > | <\r\nS  ::= x := a | skip | S1; S2 | ( S ) | if b then S1 else S2 | while b do S\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}